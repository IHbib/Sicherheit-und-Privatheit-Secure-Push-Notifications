%%
%% This is file `sample-sigconf.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `sigconf')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-sigconf.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%% The first command in your LaTeX source must be the \documentclass command.
\documentclass[sigconf]{acmart}

%% Remove copyroght notes for lecture/preprint purposes
\settopmatter{printacmref=false}
\setcopyright{none}
\renewcommand\footnotetextcopyrightpermission[1]{}
\pagestyle{plain}

\setcopyright{none}
\makeatletter
\renewcommand\@formatdoi[1]{\ignorespaces}
\makeatother

\acmConference{}{}{}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
%\setcopyright{acmcopyright}
%\copyrightyear{2018}
%\acmYear{2018}
%\acmDOI{10.1145/1122445.1122456}

%% These commands are for a PROCEEDINGS abstract or paper.
%\acmConference[Woodstock '18]{Woodstock '18: ACM Symposium on Neural
%  Gaze Detection}{June 03--05, 2018}{Woodstock, NY}
%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%  June 03--05, 2018, Woodstock, NY}
%\acmPrice{15.00}
%\acmISBN{978-1-4503-XXXX-X/18/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

 
%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Sicherheit und Privatheit von Push-Notification-Services für mobile Apps}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Chantal Bruns}
\affiliation{%
  \institution{Hochschule Bonn-Rhein-Sieg}
}
\email{chantal.bruns@smail.inf.h-brs.de}

\author{Issam Hbib}
\affiliation{%
  \institution{Hochschule Bonn-Rhein-Sieg}
}
\email{issam.hbib@smail.inf.h-brs.de}

\author{Robert Bargon}
\affiliation{%
  \institution{Hochschule Bonn-Rhein-Sieg}
}
\email{robert.bargon@smail.inf.h-brs.de}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{Bruns, Hbib, Bargon}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
  TODO
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
  <concept>
  <concept_id>10002978.10003022.10003028</concept_id>
  <concept_desc>Security and privacy~Domain-specific security and privacy architectures</concept_desc>
  <concept_significance>300</concept_significance>
  </concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Security and privacy~Domain-specific security and privacy architectures}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{push notifications, encryption, cloud messaging services}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}

ACM's consolidated article template, introduced in 2017, provides a
consistent \LaTeX\ style for use across ACM publications, and
incorporates accessibility and metadata-extraction functionality
necessary for future Digital Library endeavors. Numerous ACM and
SIG-specific \LaTeX\ templates have been examined, and their unique
features incorporated into this single new template.

If you are new to publishing with ACM, this document is a valuable
guide to the process of preparing your work for publication. If you
have published with ACM before, this document provides insight and
instruction into more recent changes to the article template.

The ``\verb|acmart|'' document class can be used to prepare articles
for any ACM publication --- conference or journal, and for any stage
of publication, from review to final ``camera-ready'' copy, to the
author's own version, with {\itshape very} few changes to the source.

\section{Grundlagen von Push-Benachrichtigungen}
TODO

\subsection{Was ist Firebase?}

Firebase ist eine Entwicklungsplattform, mit welcher es möglich ist 
Apps (mobil und webbasiert) in der Google Cloud Plattform zu entwickeln.
Es bietet durch verschiedene Services, den Entwicklern die Möglichkeit 
die App-Entwicklung zu beschleunigen und die Stabilität und Leistung 
zu überwachen. Darunter auch die Push-Notifications, welche im Folgenden 
genauer erläutert werden.

\subsection{Typischer Push-Notification-Flow}

Um die Funktionalität der Push-Benachrichtigungen herzustellen, 
werden die SDK-APIs der mobilen Plattform z.B. Apple iOS oder Android, 
verwendet, um sich damit bei einem Cloud-Messaging-Anbieter 
registrieren zu können. Dazu gehören Apple Push Notification Service 
(APNs) für iOS und Firebase Cloud Messaging (FCM) für Android.
Zuerst sendet der Cloud-Messaging-Anbieter ein Push-Token, welches wie 
eine Adresse funktioniert, mit dem es möglich ist das Gerät und die 
mobile App als Empfänger der Nachricht zu identifizieren.
Daraufhin wird das Push-Token von der mobilen App an den Server einer 
Customer-Engagement-Plattform gesendet, denn das Push-Token muss dem 
Server bekannt sein, um eine Push-Benachrichtigung an den Empfänger 
senden zu können.
Die Sicherheit, dass die personalisierten Inhalte nur vom 
beabsichtigten Benutzer empfangen werden, ist durch die Eins-zu-Eins 
Zuordnung zwischen dem Push-Token und der Kennung des Benutzers vom 
System gewährleistet.
Der Remote-Server sammelt die Nutzerdaten und Interaktionen und gibt 
den App-Entwicklern die Möglichkeit z.B. den Nachrichteninhalt so zu 
personalisieren, dass er auf die Nutzungsmuster und -attribute der 
Kunden angepasst ist.
Die personalisierte Nachricht wird an das Push-Token gebunden und 
vom Remote-Server an den Cloud-Messaging-Dienst der mobilen 
Plattform gesendet.
Der Nachrichteninhalt wird dann vom Cloud-Messaging-Dienst an das 
richtige Gerät und die mobile App gesendet und dann anschließend als 
Benachrichtigung angezeigt.

\subsection{FCM für Android}

Um Firebase Cloud Messaging-basierte Push-Benachrichtigungen in einer 
Android-App zu implementieren, werden eine mobile App, eine Verbindung 
zum FCM-Server und ein Push-Server eines Drittanbieters benötigt.
Zuerst muss Firebase zu dem Android-App-Projekt hinzugefügt werden. 
Danach ist es erforderlich sich bei FCM zu registrieren, um das 
FCM-Registrierungstoken zu erhalten. Um dann anschließend eine 
Verbindung mit den FCM-Servern herzustellen, muss das FCM-Token 
in der Android-App konfiguriert werden. Nun wird ein Push-Server 
eines Drittanbieters benötigt, damit Benachrichtigungen von der 
mobilen App an den FCM-Server gesendet werden können.
Hierfür wird oftmals der Google Play Store verwendet, der die 
Einrichtung mit den Google Play-Diensten APK erfordert. Es können 
aber auch Push-Benachrichtigungsserver eines Drittanbieters verwendet 
werden.

\subsection{Push-Notifications für Apple}

Für iOS funktionieren Push-Notifications ähnlich wie bei Android 
mit dem Unterschied, dass die App mit dem Apple Push Notification 
Service kommuniziert. Hierfür wird ein Apple Push Notification 
Authentication Key für den Apple Developer Account benötigt. 
Zuerst fordert iOS ein Gerätetoken vom Apple Push Notification 
Service (APNs) an. Danach empfängt die iOS-App das Token, mit 
welchem Push-Benachrichtigungen an die identifizierte Anwendung 
gesendet werden. Zum Schluss sendet der Server einer 
Customer-Engagement-Plattform die Benachrichtigung an den APNs 
und dann identifiziert der APNs das iOS-Gerät und die iOS-App, 
an die die Benachrichtigung gesendet werden soll.

\subsection{Grundlagen zu unsicheren Push-Notifications}

Firebase selbst bietet keine End-zu-End Verschlüsselung an, was 
die Übertragung der Push-Benachrichtigungen unsicher macht, da 
diese über Firebase unverschlüsselt übertragen werden und somit 
von Firebase ausgelesen und ausgewertet werden können. Stattdessen 
schlägt Firebase die Nutzung von Bibliotheken von Drittanbietern vor, 
unter anderem Capillary.
Apple hingegen bietet das UNNotificationServiceExtension Objekt an, 
womit verschlüsselte Push-Notifications von der App entschlüsselt 
werden können. Dabei muss der versendete Notification Payload den 
Json Key „mutable-content“ mit dem Wert 1 beinhalten, damit das 
UNNotificationServiceExtension Objekt die verschlüsselte Notification 
entschlüsselt, bevor sie im Gerät angezeigt wird.

\section{Sichere Push-Notifications}

TODO

\subsection{Grundlagen von sicheren Push Notifications}

Wenn eine Benachrichtigung eines App-Anbieters über einen Messaging 
Dienst wie FCM zum Endgerät gelangen soll, ist die Kommunikation 
zwischen Entwickler und Messaging Dienst, sowie die Kommunikation 
zwischen Messaging Dienst und Endgerät durch TLS verschlüsselt [1][2], 
jedoch wird der eigentliche Inhalt der Benachrichtigungen in Klartext 
übermittelt [1][2]. So handelt es sich dabei nicht um eine 
Ende-zu-Ende Verschlüsselung und der Inhalt der Nachricht kann von 
beispielsweise Google mitgelesen werden.

Bedenklich ist die Tatsache, dass alle Benachrichtigung recht einfach 
einer Person zugeordnet werden können und die Anbieter dieser Messaging 
Dienste meist US-amerikanische Firmen sind, welche beispielsweise 
Daten an Behörden weiterreichen müssten, falls gefordert [3].

Um den Inhalt von Push-Benachrichtigungen vor den Messaging Diensten 
zu schützen, muss der App-Anbieter sich also selbst um eine 
Ende-zu-Ende-Verschlüsselung kümmern.

Dies kann besonders wichtig sein, wenn es sich um Benachrichtigungen 
handelt, welche sensible Personen Informationen enthalten. Wenn es 
sich um Benachrichtigungen von Instant Messaging Diensten handelt, 
oder vielleicht sensiblere Daten von Banking Apps oder vergleichbarem, 
ist eine Verschlüsselung der Inhalte besonders erstrebenswert.

Eine solche Ende-zu-Ende-Verschlüsselung lässt sich über eine 
asymmetrische Verschlüsselung recht gut realisieren, wobei das 
Endgerät das Schlüsselpaar erzeugt und den Öffentlichen Schlüssel an 
den Entwickler schickt und dabei den Messaging Dienst außen vor lässt. 
Dabei muss man nicht die Funktionsweise des Messaging Dienstes 
einschränken und kann vorhandene Technologien weiter nutzen.



\subsection{Beispiel eines sicheren Notification Flow}

1. Der Anwender erzeugt auf seinem Endgerät automatisiert ein 
Schlüsselpaar, bestehend aus einem Öffentlichen und einem Privaten 
Schlüssel.

2. Der Öffentliche Schlüssel wird dem Entwickler nun über einen direkten 
Kommunikationsweg übermittelt.

3. Der Entwickler speichert nun diesen Schlüssel und verknüpft ihn Lokal 
mit dem Messaging Dienst Identifier für das spezifische Endgerät. 
Nun ist er in der Lage mit dem Öffentlichen Schlüssel seine Ausgehende 
Benachrichtigen zu verschlüsseln.

4. Die Verschlüsselte Benachrichtigung wird nun dem Messaging Dienst 
übermittelt, welcher diese, für ihn unlesbare Nachricht, an das Endgerät 
übermittelt.

5. Das Endgerät kann bei Erhalt der Benachrichtigung, durch seinen lokal 
gespeicherten Privaten Schlüssel den Inhalt entschlüsseln und die 
Benachrichtigung kann dem Nutzer angezeigt werden.

\subsection{Umsetzung in Open Source Projekten}

Capillary ist eine Bibliothek von Google, welche Drittanbieter, eine End-zu-End 
Verschlüsselung über Firebase Cloud Messaging ermöglicht. Unter anderem 
bietet sie die Schlüsselgeneration als auch Registrierung der erstellten 
asymmetrischen Schlüssel mit dem Developer Application Server, der die 
Benachrichtigungen verschlüsselt über Firebase an die App mit Capillary 
versendet. Zudem bietet Capillary die Entschlüsselung und Verschlüsselung 
der Notification clientseitig in der App als auch serverseitig an.

Capillary bietet noch weitere Funktionen, wie zum Beispiel, dass ein gestohlenes 
Endgerät die Möglichkeit der Entschlüsselung noch eingehender Benachrichtigungen 
entzogen werden kann [2].

Die Popularität dieser Bibliothek scheint, gemessen anhand der ungefähr 
450 Github Stars Stand Dezember 2021, recht eingeschränkt. Der letzte Commit 
war im Dezember 2018, womit das Projekt recht verlassen ausschaut.

Eine weitere Möglichkeit verschlüsselte Notifications zu senden, 
besteht über das Extensible Messaging and Presence Protocol (XMPP). 
XMPP selbst ist ein Standard der Internet Engineering Taswk Force (IETF), 
welcher Technologien wie instant messaging, Push Notifications, voice und 
video calls über XML ermöglicht. Dieser Standard definiert zudem die 
End-zu-End Verschlüsselung als auch Signierung von versendeten Objekten. 
Dies kann verwendet werden, um Push Notifications zu verschlüsseln.

\section{Prototyp}

Im Rahmen des Projektes sollte überprüft werden, wie oft unsichere Push 
Notifications in Apps benutzt wurden. Hierfür wurden nur Android Apps 
betrachtet. Das erste Analysekriterium achtet auf die Benutzung von 
„NotificationCompat“ mit Hilfe von einem Stringabgleich, welche zu den 
Android Schnittstellen gehört und das Senden von Push Nachrichten ermöglicht. 
Wenn diese vorhanden ist, wird davon ausgegangen, dass eine App 
Notifications abschicken kann und dann wird auf die nächsten beiden 
Analysekriterien geachtet.
Die zweiten und dritten Analysekriterien untersuchen die Apps auch mit 
einem Stringabgleich nach den beiden Strings „Capillary“ und „XMPP“. Ist 
der String „Capillary“ vorhanden, so wird davon ausgegangen, dass die App 
Capillary unterstützt, da diese Bibliothek zum Zweck der End-zu-End 
Verschlüsselung von Push Notifications erstellt wurde. Ist der String „XMPP“ 
vorhanden, so kann nicht zwingend davon ausgegangen werden, dass eine 
End-zu-End Verschlüsselung unterstützt wird, da die Ende-zu-Ende 
Verschlüsselung im Standard nur als optionales Feature definiert wurde.

\subsection{TODO}
Zum Herunterladen der Apps wurde das Fork vom Python Projekt GooglePlayAPI 
von TheZ3ro benutzt, zudem musste das Requests Python Projekt auf die Version 
2.20.0 herabgestuft werden, da eine höhere Version inkompatibel ist. 
Als weiteres wurde ein eigenes Python Skript geschrieben, welches die 
GooglePlayAPI Bibliothek importiert und für den Login benutzt. Bei dem Login 
wird ein neues Gerät mit der Sprachumgebung, die Zeitzone und einem 
Gerätecodenamen mit dem benutzten Account initialisiert. Im Falle der Tests 
waren dies die Werte en\_US für ein Gerät im US-Amerikanischen Raum, die 
Zeitzone UTC und der Gerätecodename hero2lte, welches für das Samsung 
Galaxy S7 Edge steht.

\subsection{TODO}
Nach dem erfolgreichen Login wird ein Logger für das LogFile als auch 
entsprechende Counter für die Anzahl tatsächlich überprüfter Apps, da sich 
manche Apps nicht herunterladen lassen und die Anzahl von Apps mit den 
Strings „Capillary“ und „XMPP“.
Danach wird ein CSV Reader benutzt, um eine Datei auszulesen, die aus 
Application IDs der zu testenden Apps getrennt mit Zeilenumbrüchen besteht. 
Hierbei wurden mit einem Javascript Skript und nachträglicher manuellen 
Anpassung aus der Seite „androidrank.org“ die Application IDs der Top 500 
Apps der Bereiche „Health\_And\_Fitness“ und „Medical“ und in entsprechende 
zwei Dateien zusammengefasst, welche dem Skript zugefügt wurden.

\subsection{TODO}
Sobald die erste Application ID gelesen wurde, versucht das Skript die App 
in einen temporären Ordner herunterzuladen. Schlägt dies fehl, wird die 
nächste App iteriert. Wurde die App erfolgreich heruntergeladen, wird diese 
zunächst mit dem unzip Befehl entpackt, dann wird daraufhin der Inhalt der 
entpackten App mit dem grep Befehl nach den oben genannten Kriterien 
überprüft und zuletzt die entsprechenden Counter erhöht, sowie die 
Application ID mit dem gefundenen Wert in die LogDatei geschrieben, falls 
die App Capillary und/oder XMPP benutzt.



%%
%% The acknowledgments section is defined using the "acks" environment
%% (and NOT an unnumbered section). This ensures the proper
%% identification of the section in the article metadata, and the
%% consistent spelling of the heading.
\begin{acks}
To Robert, for the bagels and explaining CMYK and color spaces.
\end{acks}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{sample-base}

%%
%% If your work has an appendix, this is the place to put it.
\appendix

\section{Research Methods}

\subsection{Part One}

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Morbi
malesuada, quam in pulvinar varius, metus nunc fermentum urna, id
sollicitudin purus odio sit amet enim. Aliquam ullamcorper eu ipsum
vel mollis. Curabitur quis dictum nisl. Phasellus vel semper risus, et
lacinia dolor. Integer ultricies commodo sem nec semper.

\subsection{Part Two}

Etiam commodo feugiat nisl pulvinar pellentesque. Etiam auctor sodales
ligula, non varius nibh pulvinar semper. Suspendisse nec lectus non
ipsum convallis congue hendrerit vitae sapien. Donec at laoreet
eros. Vivamus non purus placerat, scelerisque diam eu, cursus
ante. Etiam aliquam tortor auctor efficitur mattis.

\section{Online Resources}

Nam id fermentum dui. Suspendisse sagittis tortor a nulla mollis, in
pulvinar ex pretium. Sed interdum orci quis metus euismod, et sagittis
enim maximus. Vestibulum gravida massa ut felis suscipit
congue. Quisque mattis elit a risus ultrices commodo venenatis eget
dui. Etiam sagittis eleifend elementum.

Nam interdum magna at lectus dignissim, ac dignissim lorem
rhoncus. Maecenas eu arcu ac neque placerat aliquam. Nunc pulvinar
massa et mattis lacinia.

\end{document}
\endinput
%%
%% End of file `sample-sigconf.tex'.
